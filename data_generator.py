import streamlit as st
import pandas as pd
import plotly.express as px
from textblob import TextBlob

# --- PAGE CONFIG ---
st.set_page_config(
    page_title="NexGen Logistics Tool",
    page_icon="üì¶",
    layout="wide"
)

# --- SIDEBAR (MY PROFILE) ---
with st.sidebar:
    # Using a generic logistics icon
    st.image("https://cdn-icons-png.flaticon.com/512/759/759163.png", width=80)
    st.write("### Developer Profile")
    st.write("**Name:** Surabhi Singh")
    st.write("**ID:** 22BCE10724")
    st.info("Build: v1.1 (Prescriptive Logic)")

# --- STEP 1: LOADING DATA ---
@st.cache_data
def load_data():
    """
    Loading the 4 CSV files generated by the data_generator script.
    Merging them here to create a single 'master' dataset for analysis.
    """
    try:
        df_orders = pd.read_csv("data/orders.csv")
        df_fleet = pd.read_csv("data/vehicle_fleet.csv")
        df_feedback = pd.read_csv("data/customer_feedback.csv")
        # We load costs just in case, though mostly used for backend calculations
        df_costs = pd.read_csv("data/cost_breakdown.csv")
    except:
        st.error("Error: CSV files missing. Please run data_generator.py first.")
        return None, None

    # --- SENTIMENT ANALYSIS (NLP) ---
    # I'm using TextBlob to convert customer text into a number (-1 to 1).
    # This allows the algorithm to mathematically weigh "Customer Happiness".
    df_feedback["Sentiment_Score"] = df_feedback["Feedback_Text"].astype(str).apply(
        lambda x: TextBlob(x).sentiment.polarity
    )

    # Calculate average sentiment per customer so we know who is 'At Risk'
    avg_scores = df_feedback.groupby("Customer_ID")["Sentiment_Score"].mean().reset_index()

    # Merge this back into the main orders file
    # Left join ensures we keep orders even if they are new customers (no feedback yet)
    master_df = pd.merge(df_orders, avg_scores, on="Customer_ID", how="left")
    
    # Fill NaN with 0 (Neutral) for new customers
    master_df["Sentiment_Score"] = master_df["Sentiment_Score"].fillna(0)

    return master_df, df_fleet

# Load the data
data, fleet = load_data()

# --- STEP 2: THE DECISION ALGORITHM ---
def get_best_mode(order_row, weight_dict):
    """
    This function takes an order and rankings the 3 transport options.
    It uses the weights (sliders) provided by the user to calculate a score.
    """
    
    # Define the characteristics of our 3 modes (Simulated averages)
    modes = [
        {"Type": "Standard Truck", "Cost": 50,  "Time": 2.5, "CO2": 250},
        {"Type": "Express Bike",   "Cost": 80,  "Time": 1.2, "CO2": 40},
        {"Type": "Electric Van",   "Cost": 60,  "Time": 3.0, "CO2": 0}
    ]

    results = []

    for m in modes:
        # Calculate Weighted Score (Lower score is better)
        # Cost + Speed + Sustainability
        score = (m["Cost"] * weight_dict["w_cost"]) + \
                (m["Time"] * 20 * weight_dict["w_speed"]) + \
                (m["CO2"] * 0.1 * weight_dict["w_green"])

        # --- CHURN PREVENTION LOGIC ---
        # If the customer is angry (Sentiment < -0.1), we cannot afford to be slow.
        # So I add a heavy penalty to any option taking longer than 2 hours.
        if order_row["Sentiment_Score"] < -0.1 and m["Time"] > 2.0:
            score += 500  # Huge penalty pushes this option to the bottom
            note = "‚ö†Ô∏è Risk: Customer Unhappy"
        else:
            note = "Viable"

        # Save the result
        results.append({
            "Mode": m["Type"],
            "Cost": m["Cost"],
            "Time": m["Time"],
            "Emission": m["CO2"],
            "Score": score,
            "Note": note
        })

    # Return sorted dataframe (Best option first)
    return pd.DataFrame(results).sort_values("Score")

# --- STEP 3: DASHBOARD LAYOUT ---

st.title("üöõ NexGen Smart-Switch Engine")
st.markdown("### Prescriptive Logistics Optimization")
st.markdown("This tool helps managers decide the **best fulfillment method** by balancing Cost, Speed, and Carbon Impact.")

st.divider()

# KPI Row
kpi1, kpi2, kpi3, k4 = st.columns(4)
kpi1.metric("Pending Orders", len(data))
kpi2.metric("Fleet Size", len(fleet))
kpi3.metric("Avg Customer Sentiment", f"{data['Sentiment_Score'].mean():.2f}")

# Calculate how many customers are "At Risk" (Negative score)
risk_count = len(data[data['Sentiment_Score'] < -0.1])
k4.metric("At-Risk Customers", risk_count, delta="Needs Attention", delta_color="inverse")

st.markdown("---")

# Split layout: Controls on Left, Results on Right
col_left, col_right = st.columns([1, 2])

with col_left:
    st.subheader("1. Strategic Priorities")
    st.write("Adjust weights based on business goals:")
    
    w_cost = st.slider("Priority: Save Cost", 0.0, 1.0, 0.5)
    w_speed = st.slider("Priority: Fast Delivery", 0.0, 1.0, 0.5)
    w_green = st.slider("Priority: Reduce CO2", 0.0, 1.0, 0.5)
    
    # Normalize weights so they add up to 1 (Math requirement)
    total_w = w_cost + w_speed + w_green
    if total_w == 0:
        w_cost = w_speed = w_green = 0.33
    else:
        w_cost /= total_w
        w_speed /= total_w
        w_green /= total_w
        
    st.markdown("---")
    st.subheader("2. Select Order")
    
    # Dropdown to pick an order
    selected_id = st.selectbox("Order ID:", data["Order_ID"].head(10))
    
    # Get that specific row
    curr_order = data[data["Order_ID"] == selected_id].iloc[0]
    
    st.info(f"**Customer:** {curr_order['Customer_ID']}\n\n**Value:** ${curr_order['Order_Value_USD']}")
    
    # Check Sentiment
    s_score = curr_order['Sentiment_Score']
    if s_score < -0.1:
        st.error(f"‚ö†Ô∏è Churn Risk Detected (Score: {s_score:.2f})")
    else:
        st.success(f"‚úÖ Customer Stable (Score: {s_score:.2f})")

with col_right:
    st.subheader("3. AI Recommendation")
    
    # Run the algorithm
    my_weights = {"w_cost": w_cost, "w_speed": w_speed, "w_green": w_green}
    result_df = get_best_mode(curr_order, my_weights)
    
    # The top row is the winner
    best_choice = result_df.iloc[0]
    
    # Dynamic styling for the recommendation box
    if "Electric" in best_choice["Mode"]:
        box_color = "green"
    elif "Express" in best_choice["Mode"]:
        box_color = "orange"
    else:
        box_color = "blue"
        
    st.markdown(f":{box_color}[**Recommended Mode:**] **{best_choice['Mode']}**")
    st.caption("Optimized based on your priorities & customer risk profile.")
    
    # Show the table
    st.dataframe(result_df[["Mode", "Cost", "Time", "Emission", "Note"]], use_container_width=True)

st.markdown("---")

# --- FINAL VISUALIZATION ---
st.subheader("Network Risk Analysis")
st.caption("Visualizing high-value orders vs. Customer Sentiment.")

fig = px.scatter(
    data, 
    x="Order_Value_USD", 
    y="Sentiment_Score", 
    color="Priority",
    size="Order_Value_USD",
    title="Customer Value vs. Satisfaction"
)
st.plotly_chart(fig, use_container_width=True)

# Footer
st.markdown("---")
st.markdown("<div style='text-align: center'><b>Developed by Surabhi Singh (22BCE10724)</b></div>", unsafe_allow_html=True)